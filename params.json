{"name":"8 Ball Pool Game with OpenGL & C++","tagline":"","body":"**Abstract**: In this project, I build an interacting billiard game using modern OpenGL API. This game simulates a table with 6 pockets and 16 balls including a cue ball. The cue ball can be hit with a force using the mouse motions such that it gets an initial velocity. And the balls can rolling on the table by simulating friction. I also implement the necessary physics to modeling the collision between a ball and a sidewall, and between two balls. In addition, per-fragment shading is also implemented to achieve better lighting effect. \r\n\r\n\r\nThis report contains five part: \r\n\r\n1. Geometry and rendering setup\r\n2. Interaction of hitting a ball\r\n3. Motion of a ball\r\n4. Collision handling\r\n5. Summary and discussion\r\n\r\n\r\nPart 1 Geometry and rendering setup\r\n\r\nFirst, we create a sphere mesh for drawing the balls and also a table mesh. And then we bind 16 textures to all the balls. Figure 1 shows the mesh and textures for pool balls. \r\n\r\nFigure 1 The sphere mesh and pool balls textures\r\n\r\nFigure 2 shows the initial  setup, including a table, 16 balls and 6 pockets.\r\n\r\n\r\nFigure 2 The initial setup of our pool game with the table, balls, pocket and lighting\r\n\r\n\r\nFigure 3 The shining spots on ball surfaces show per-fragment shading\r\n\r\n\r\n\r\n\r\nPart 2 Interaction of hitting a ball\r\n\r\nIn this part, we implement an interface for hitting a ball. We can press down the left button of the mouse, mouse the cursor to a ball surface and release the mouse. The end position on the ball is the hitting point, and the vector from which the mouse moved towards the hitting point gives the force on the ball at the hitting point. \r\n\r\nThe implementation includes:\r\n1. Auto detect the ID of the hitted ball\r\n2. Calculate the force\r\n3. Assign an initial velocity to the hitted ball\r\n\r\nFor detecting the ball ID, we use color picking method by creating another render routine. For calculating hitting force we use windows coordinates to decide the size and direction of the force. And we use the following equations to derive the initial velocity for the hitted ball.\r\n\r\n\r\nHere, the Δt is the amount of time the cue is in contact with the ball. The k is a constant coefficient. The m is the mass of the cue ball and the vector x is the difference between the starting and end points of the mouse hitting motion. The vector r represents the radius from the center that the cue ball was stuck.\r\n\r\nFigure 4 Let’s start our game!\r\nPart 3 Motion of a ball\r\n\r\nOnce the ball has an initial linear and angular velocities, it begins to move across the table. After it leaves the tip of the cue, the only force acting on the cue ball is the force of friction from the table. The motions of our balls include sliding and rolling. We use the following equations to update the linear and angular velocities of the ball when it moves across the table.\r\n \r\n\r\nHere we have a new vector vp, which is the perimeter velocity of the ball at the point of contact with table. The us is the coefficient of sliding friction and g is the force of gravity. \r\n\r\n\r\nFigure 5 The game is going on!\r\n\r\n\r\nPart 4 Collision handling\r\n\r\nThe collision between two balls or between a ball and a wall can be detected by calculating the distance between the centers of two ball or between the center of a ball  and the wall. \r\n\r\n\r\n1. Collision between two balls\r\n\r\nIf a collision is detected, we need to update the velocity vectors of the ball involved. And we use conservation of energy and conservation of momentum principles to derive the updated velocities. The following equations show the final results.\r\n\r\nFor linear velocity:\r\n\r\nFirst we calculate the normal to the collision plane. The vectors vn1 and vt1 are the normal and tangential components of the velocity of ball 1. And the vn2 and vt2 are for ball 2. The results show that the new linear velocities of two balls simply come from exchanging the normal components of two old velocities.\r\n\r\nFor angular velocity:\r\n  \r\nThe ub is the coefficient of friction between two balls. The vector vpR is the relative perimeter velocity between two balls. The above equation shows the change for ball 2, and ball 1 has exact same change. \r\n\r\n2. Collision between a ball and a wall\r\n\r\nIt is much easy to implement the collision between a ball and a wall. Similar to the reflection principle of light, we use the following equations for updating the velocity.\r\nv’ = vt - vn\r\nw’ = wn - wt\r\nFirst we calculate the normal of the wall. The vector vn and vt are the normal and tangential component of incident velocity of the ball, and v’ is the reflection velocity. Similarly we apply wn and wt to angular velocity.\r\n\r\n\r\nPart 5 Summary\r\n\r\nIn addition to the above implementations, the balls can also go into the pockets. If the ball is cue ball, it will automatically come out again immediately at the center of table. And the future work can be simulating the players and a chalk, which are easy to implement.\r\n\r\n\r\n\r\nFigure 6 Finally we finish the game. Yep!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}